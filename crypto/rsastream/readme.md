# RSA без регистрации и СМС
crypto, 300 points

> Будущее уже здесь! Мы нашли в Интернете новый стартап по дешифровке шестнадцатеричных чисел. Правда, у него есть свой секрет, расшифровывать который он не хочет. Однако, мы вытащили его исходники и зашифрованный секрет. Может быть, с ними что-то можно сделать?
> 
> Говорят, что у сервиса есть консольный интерфейс: `nc crypto.upmlctf.ru 5005`

```
encrypted_secret = 0x5c25cfe2dbbb9467d8f5e94733abba928a444b7d7e2f2166bc3c8eb0f8d414f3d556f5e513319c8e9bf530b6208b8c4804def2eb7ad669593283abdaf18c849dc36c3e93cc2f256e21b59937b98234c93a639df5284330d9118dfa0b9e0911f70e2d3bf94fe5d2095c8bcfdce933856ad01a846dbc9ddffc6b0deee2a7238effc533bf1a881a360f418b405a6f32420072ac8194169ed65a3e7df02dd99555f41a75f23a60831e79a9a2f3e812536a80d5f7418d5354b00db0086d74b8d430b202da9bdeec36effb8eddefaa0121a4b89b30284aa31aafc5d5f40461450e43b015c130e55530668959e949804effd97e6e41cacd4b4b105c956cae3a577e13c6
```

[Вложение](app/script.py)

*Hint* (-100): Как работает возведение в степень, и что можно сделать, когда запрещено ровно одно число?

## Write-up
Итак, об RSA мы уже немного знаем из прошлого таска. Из кода мы знаем N и e, а сервис умеет расшифровывать любое число с приватным ключом (N, d).

Если спросить зашифрованный секрет, то сервис откажется его расшифровывать.

Как работает расшифровка в RSA? Очень просто: `result = cipher^d mod n`. 

Во-первых, в таске был небольшой баг: по идее предполагалось, что должно приниматься число в интервале [0, n), но я забыл это проверить, и принималось любое число.

Как это эксплуатировать: ты когда-нибудь слышал про бином Ньютона? Так вот, этот бином гласит, что `(cipher + n) ^ d = cipher^d + d * cipher^(d-1) * n + d(d-1)/2 * cipher^(d-2) * n^2 + ... + n^d`.

Обрати внимание, что **все слагаемые, начиная со второго**, нацело делятся на n. А значит, `(cipher + n) ^ d mod n = cipher^d mod n`!

Но `(cipher + n)` уже не является заблокированным числом, поэтому мы его можем ввести. Сервис его расшифровывает, отдает hex, получаем из него флаг.

Второй вариант решения, эксплуатирующего эту уязвимость, требует ещё одного допущения: длина флага сильно меньше длины числа n (более того, она меньше длины корня из n). Тогда попросим сервис расшифровать `encrypted^2` и получим `flag^2 mod n`. Но если `flag^2 < n`, то `flag^2 mod n = flag^2` и, извлекая квадратный корень, получим флаг.

Если бы этой уязвимости не было, то таск надо было решать так: попросим расшифровать число 2 (да, так тоже можно!) — получим какое-то число `two = 2^d mod n`. Попросим расшифровать `encrypted/2` — получим `flag_two = (encrypted/2)^d mod n`.

Добавим немного математики: `(flag_two * two) mod n = (2^d mod n) * ((encrypted/2)^d mod n) mod n = (2^d * (encrypted/2)^d) mod n = (2 * (encrypted/2))^d mod n = encrypted^d mod n = flag`

То есть получившиеся «расшифровки» нужно перемножить и взять остаток от деления на n.

Флаг: **uctfyouneedsomepadding**
