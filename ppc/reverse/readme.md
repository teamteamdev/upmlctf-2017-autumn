# Not easy reverse
ppc, 150 points

> Эта программа делает что-то непонятное. Не поможешь узнать её секрет?

[Вложение](ppc150.py)

## Write-up

Итак, программа на Python 3 читает флаг, проверяет страшное условие и выводит `Success` на верный флаг. Давайте разбираться:

1. `len(flag) == 22` — длина флага 22. Символы в строке нумеруются с 0 до 21
2. Из формата знаем, что флаг начинается с `uctf`
3. `flag[9:3:-1] == "yz4rc_"` — перевернутая строка с 4 по 9 символ. Значит, символы 4-9 равны `_cr4zy`
4. Переменные с названиями `O00...` — обфускация, заменим их на `i`
5. `sum([ord(i) for i in flag])//2 == 967` — сумма ASCII-кодов всех символов флага, деленная пополам — 967. Значит, просто сумма равна 1934
6. `''.join([chr(ord(i)^42) for i in flag[10:15]]) == 'uibou'` — это уже посложнее. Эта штука xor'ит символы с символом 42. Чтобы вернуть исходную строку, снова поxorим — `u`→`_` и т.д. — получаем `_CHE_`.
7. `''.join([chr((ord(i)-65+8)+ord('a')) for i in flag[20:14:-1])` — заметим, что `ord('a') = 97`, с учетом этого оператор превращается в `''.join([chr(ord(i) + 40) for i in flag[20:14:-1]])`. То есть к коду символа прибавляется 40. Это равно `'s' * 4 + '{' * 2 = 'ssss{{'`, а значит, в оригинале было `KKKKSS`, но это перевернутая строка с 20 по 15 символ. Исходная — `SSSSKK`
8. Из суммы кодов символов находим 21-й символ — `!`

Также, так как в пункте 5 деление нацело, сумма могла быть равна 1935, а последний символ — `"`.

Флаг: `uctf_cr4zy_CHE_SSSSKK!`